
/*
    CBytePtr.java, generated by gen_pointer_wrapper.py.

    Copyright (C) 2010 Darrell Karbott

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2.0 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

    Author: djk@isFiaD04zgAgnrEC5XJt1i4IE7AkNPqhBG5bONi6Yks

    This file was developed as component of
    "fniki" (a wiki implementation running over Freenet).

    DON'T MODIFY THIS FILE BY HAND.
*/

package wormarc.hgdeltacoder.cptr;
import wormarc.hgdeltacoder.ported.*;

// Generated by gen_pointer_wrapper.py
public class CBytePtr {
    public CBytePtr(byte[] rep, int pos) {
        mRep = rep;
        mPos = pos;
    }

    public CBytePtr(byte[] rep) {
        mRep = rep;
        mPos = 0;
    }

    public final CBytePtr copyPtr() {
        return new CBytePtr(mRep, mPos);
    }

    public final CBytePtr copyPtrWithOffset(int offset) {
        return new CBytePtr(mRep, mPos + offset);
    }

    public boolean equals(Object obj) {
        if (obj == null || (!(obj instanceof CBytePtr))) {
            return false;
        }

        CBytePtr other = (CBytePtr)obj;
        if (mRep != other.mRep) {
            throw new IllegalArgumentException("Illegal comparison, pointers " +
                                               "reference different memory " +
                                               "blocks!");
        }

        return (mPos  == other.mPos);

    }

    public final int minus(CBytePtr other) {
        if (mRep != other.mRep) {
            throw new IllegalArgumentException("Illegal comparison, pointers " +
                                               "reference different memory " +
                                               "blocks!");
        }
        return mPos - other.mPos;
    }

    public final byte deref() {
        return mRep[mPos];
    }

    public final void plusPlus() {
        mPos ++;
    }

    public final byte bracket(int index) {
        return mRep[index + mPos];
    }

    public final byte setValueAt(int offset, byte value) {
        mRep[offset + mPos] = value;
        return mRep[offset + mPos];
    }

    public final static CBytePtr alloc(int size) {
        byte[] values = new byte[size];
        return new CBytePtr(values);
    }

    public final void realloc(int size) {
        byte[] values = new byte[size];
        mRep = values;
        mPos = 0;
    }

    public final void free() {
        mRep = null;
        mPos = -1;
    }

    public final void set(byte[] rep, int pos) {
        mRep = rep;
        mPos = pos;
    }

    public final int pos() {
        return mPos;
    }

    public final byte[] unsafeRep() {
        return mRep;
    }

    public String toString() {
        int allocated = 0;
        if (mRep != null) {
           allocated = mRep.length;
        }
        return "{allocated=" + allocated + ", pos=" + mPos +"}";
    }

    private int mPos;
    private byte[] mRep;
}
